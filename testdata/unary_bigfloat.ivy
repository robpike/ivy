# Copyright 2014 The Go Authors. All rights reserved.
# Use of this source code is governed by a BSD-style
# license that can be found in the LICENSE file.

# Unary operations on floats. The simplest but hacky way to get a float is to
# take a square root.

)format "%.16g"
sqrt 2
	1.414213562373095

)format "%.16g"
+sqrt 2
	1.414213562373095

)format "%.16g"
-sqrt 2
	-1.414213562373095

)format "%.16g"
/sqrt 2
	0.7071067811865475

)format "%.16g"
/-sqrt 2
	-0.7071067811865475

)format "%.16g"
**log e
	2.718281828459045

# Was bug - stopped when series hit 0. Issue 96
**-1
	0.367879441171

# Was bug - overwrote argument. Issue 30.
log pi
pi
	1.14472988585
	3.14159265359

(**pi) - pi
	19.9990999792

not sqrt 2
	0

log 1
	0

(2 log 8) - 3
	0

(5 log 5**12345) - 12345
	0

0, (-12345 + 5 log 5**12345) rho 1
	0

(2 log 8) rho 1
	1 1 1

sin 1e4
	-0.305614388888

)format "%.8f"
sin (pi/4)*(1-iota 9)
	0.00000000 -0.70710678 -1.00000000 -0.70710678 0.00000000 0.70710678 1.00000000 0.70710678 0.00000000

)format "%.8f"
cos (pi/4)*(1-iota 9)
	1.00000000 0.70710678 0.00000000 -0.70710678 -1.00000000 -0.70710678 0.00000000 0.70710678 1.00000000

)format "%.8f"
tan 1 - iota 6
	0.00000000 -1.55740772 2.18503986 0.14254654 -1.15782128 3.38051501

)format "%.8f"
asin .2 * -6 + iota 11
	-1.57079633 -0.92729522 -0.64350111 -0.41151685 -0.20135792 0.00000000 0.20135792 0.41151685 0.64350111 0.92729522 1.57079633

)format "%.8f"
acos .2 * -6 + iota 11
	3.14159265 2.49809154 2.21429744 1.98231317 1.77215425 1.57079633 1.36943841 1.15927948 0.92729522 0.64350111 0.00000000

)format "%.8f"
atan -6 + iota 11
	-1.37340077 -1.32581766 -1.24904577 -1.10714872 -0.78539816 0.00000000 0.78539816 1.10714872 1.24904577 1.32581766 1.37340077

# Double-check atan values near 1, which use a different algorithm (see value/asin.go).
atan .9 .95 .99 1 1.01 1.05 1.1
	0.732815101787 0.759762754876 0.780373080067 0.785398163397 0.790373246728 0.80978357257 0.832981266674

)format "%.8f"
sinh -6 + iota 11
	-74.20321058 -27.28991720 -10.01787493 -3.62686041 -1.17520119 0.00000000 1.17520119 3.62686041 10.01787493 27.28991720 74.20321058

)format "%.8f"
cosh -6 + iota 11
	74.20994852 27.30823284 10.06766200 3.76219569 1.54308063 1.00000000 1.54308063 3.76219569 10.06766200 27.30823284 74.20994852

)format "%.8f"
tanh -6 + iota 11
	-0.99990920 -0.99932930 -0.99505475 -0.96402758 -0.76159416 0.00000000 0.76159416 0.96402758 0.99505475 0.99932930 0.99990920

)format "%.8f"
asinh .2 * -6 + iota 11
	-0.88137359 -0.73266826 -0.56882490 -0.39003532 -0.19869011 0.00000000 0.19869011 0.39003532 0.56882490 0.73266826 0.88137359

)format "%.8f"
acosh  iota 11
	0.00000000 1.31695790 1.76274717 2.06343707 2.29243167 2.47788873 2.63391579 2.76865938 2.88727095 2.99322285 3.08896990

)format "%.8f"
atanh .19 * -6 + iota 11  # .19 not .2 to avoid +-1.
	-1.83178082 -0.99621508 -0.64752284 -0.40005965 -0.19233717 0.00000000 0.19233717 0.40005965 0.64752284 0.99621508 1.83178082

sgn -sqrt 2
	-1

sgn sqrt 2
	1

)format "%.8f"
log iota 6
	0.00000000 0.69314718 1.09861229 1.38629436 1.60943791 1.79175947

log 1e1000
	2302.58509299

log 1e-1000
	-2302.58509299

)format "%.16g"
abs -sqrt 2
	1.414213562373095


)format "%.16g"
abs sqrt 2
	1.414213562373095

)format "%.16g"
floor -sqrt 2
	-2

)format "%.16g"
floor sqrt 2
	1

)format "%.16g"
ceil -sqrt 2
	-1

)format "%.16g"
ceil sqrt 2
	2

)format "%.16g"
rho rho sqrt 2
	0

)format "%.16g"
,sqrt(2)
	1.414213562373095

# Results should be integers (the cutover is defined in BigFloat.shrink and is arbitrary).
sqrt 1e10 1e20 1e40 1e60
	100000 10000000000 100000000000000000000 1000000000000000000000000000000

# Results should be floats.
sqrt 1e80 1e100
	1e+40 1e+50

# Results should always be floats.
sqrt 2e10 2e20 2e40 2e60
	141421.356237 14142135623.7 1.41421356237e+20 1.41421356237e+30

# Was a bug.
sqrt(0)
	0

# Successive approximations to e.
(float 1+10**-iota 9) ** 10**iota 9
	2.5937424601 2.70481382942 2.71692393224 2.71814592683 2.71826823717 2.71828046932 2.71828169254 2.71828181487 2.7182818271

# http://www.futilitycloset.com/2015/06/28/made-to-order-4/
# Decimal expansion gives Fibonacci sequence every 24 digits.
# Explanation at https://news.ycombinator.com/item?id=9816375
)format '%.1000g'
/999999999999999999999998999999999999999999999999
	1.000000000000000000000001000000000000000000000002000000000000000000000003000000000000000000000005000000000000000000000008000000000000000000000013000000000000000000000021000000000000000000000034000000000000000000000055000000000000000000000089000000000000000000000144000000000000000000000233000000000000000000000377000000000000000000000610000000000000000000000987000000000000000000001597000000000000000000002584000000000000000000004181000000000000000000006765000000000000000000010946000000000000000000017711000000000000000000028657000000000000000000046368000000000000000000075025000000000000000000121393000000000000000000196418000000000000000000317811000000000000000000514229000000000000000000832040000000000000000001346269000000000000000002178309000000000000000003524578000000000000000005702887000000000000000009227465000000000000000014930352000000000000000024157817000000000000000039088169000000000000000063245986000000000000000102334155000000000000000165580141000000000000000267914296e-48

# Test printing of huge numbers.
sqrt 1e50000
	1e+25000

box sqrt 2
	1.41421356237

first sqrt 2
	1.41421356237

# Random numbers
)seed 0
rand 3
	1.01291904422

# High precision, not float64s.
)seed 0
1e1000 * rand 1e-1000
	0.337639681406

# Test stats. For a uniform distribution, ideally: mean = .5,  ùõî = 1/‚àö12 = 0.2887
)seed 0
x = rand 10000 rho 1
mean = (+/ x) / 10000
sigma = sqrt 1/10000 * +/(x - mean) ** 2
mean sigma
	0.504330430281 0.287168011835

# There is a (possible?) but in big.Float.Copy that made this not work.
# BigFloat.inverse would change the value of floatOne. This is a simple
# check against that; when broken, the output is 0.5 0.5 (!).
/sqrt 2; /sqrt 2
	0.707106781187 0.707106781187

# PR 228: argument with prec < conf.floatPrec
)prec 64
a = float 2
)prec 128
(sqrt a) == sqrt 2
	1

# PR 228: Argument with prec > conf.floatPrec
)prec 256
a = float 2
)prec 128
(sqrt a) == sqrt 2
	1

# PR 228: Same test for BigFloat.Sprint
)prec 64
a = float 1 << 10000
)prec 128
)format "%.30g"
a
	1.99506311688075838488374216268e+3010 
