// Copyright 2025 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

//go:build ignore
// +build ignore

//go:generate go run libgen.go

package main

import (
	"bufio"
	"bytes"
	"fmt"
	"io/fs"
	"io/ioutil"
	"log"
	"os"
	"sort"
	"strconv"
	"strings"

	"robpike.io/ivy/config"
	"robpike.io/ivy/exec"
	"robpike.io/ivy/parse"
	"robpike.io/ivy/scan"
	"robpike.io/ivy/state"
	"robpike.io/ivy/value"
)

type library struct {
	name string
	doc  string
	ops  string
	vars string
	src  string
}

type directory []library

func (d directory) Len() int           { return len(d) }
func (d directory) Less(i, j int) bool { return d[i].name < d[j].name }
func (d directory) Swap(i, j int)      { d[i], d[j] = d[j], d[i] }

var out *bufio.Writer
var dir directory

func s(str string) {
	out.WriteString(str)
	out.WriteByte('\n')
}

func printf(format string, args ...interface{}) {
	s(fmt.Sprintf(format, args...))
}

func main() {
	fd, err := os.Create("_libdefs.tmp")
	if err != nil {
		log.Fatal(err)
	}
	defer fd.Close()
	defer os.Remove("_libdefs.tmp")

	out = bufio.NewWriter(fd)
	defer out.Flush()

	s(`// Code generated by "go generate robpike.io/ivy/lib"; DO NOT EDIT.`)
	s("")
	s("package lib")
	s("")
	s(`import _ "embed"`)
	s("")

	err = fs.WalkDir(os.DirFS("./lib"), ".", embed)
	if err != nil {
		log.Fatal(err)
	}

	sort.Sort(dir) // The testing one does not get installed.

	fmt.Fprint(out, "var directory = []*Library{\n")
	var testEntry *library
	for _, entry := range dir {
		if entry.name == "_test" { // Hide it unless testing.
			testEntry = &entry
			continue
		}
		fmt.Fprintf(out, "\t&Library{\n")
		fmt.Fprintf(out, "\t\tName:   %q,\n", entry.name)
		fmt.Fprintf(out, "\t\tDoc:    %s,\n", entry.doc) // %s not %q
		fmt.Fprintf(out, "\t\tOps:    %q,\n", entry.ops)
		fmt.Fprintf(out, "\t\tSource: %s,\n", entry.name)
		fmt.Fprintf(out, "\t\tVars:   %q,\n", entry.vars)
		fmt.Fprintf(out, "\t},\n")
	}
	fmt.Fprint(out, "}\n")

	if testEntry != nil {
		fmt.Fprintln(out, "")
		fmt.Fprintln(out, "var testLibrary = &Library{")
		fmt.Fprintf(out, "\tName:   %q,\n", testEntry.name)
		fmt.Fprintf(out, "\tDoc:    %s,\n", testEntry.doc) // %s not %q
		fmt.Fprintf(out, "\tOps:    %q,\n", testEntry.ops)
		fmt.Fprintf(out, "\tSource: %s,\n", testEntry.name)
		fmt.Fprintf(out, "\tVars:   %q,\n", testEntry.vars)
		fmt.Fprintln(out, "}")
	}
	os.Rename("_libdefs.tmp", "libdefs.go")
}

func embed(path string, d fs.DirEntry, err error) error {
	if err != nil {
		return err
	}
	if !strings.HasSuffix(path, ".ivy") {
		return nil
	}
	base := path[:len(path)-len(".ivy")]
	fmt.Fprintf(out, "//go:embed lib/%s\n", path)
	fmt.Fprintf(out, "var %s string\n", base)
	fmt.Fprintln(out, "")
	data, err := ioutil.ReadFile("lib/" + path)
	if err != nil {
		log.Fatal(err)
	}

	// The ops.
	file := strings.Split(string(data), "\n")
	entry := library{
		name: base,
		doc:  doc(file),
		ops:  ops(file),
		vars: vars(path, data),
	}

	dir = append(dir, entry)
	return nil
}

// vars returns a list of global variables.
func vars(path string, data []byte) string {
	var conf config.Config
	conf.SetPrompt("") // Sufficient to initialize.
	context := exec.NewContext(&conf)
	scanner := scan.New(state.New(context), path, bytes.NewReader(data))
	parser := parse.NewParser(path, scanner, context)
	vars := []string{}
	for {
		exprs, ok := parser.Line()
		if !ok {
			break
		}
		// Variables are defined by top-level BinaryExprs with op "=".
		for _, expr := range exprs {
			if s, ok := expr.(*value.Statement); ok {
				expr = s.Parse(context)
			}
			if assign, ok := expr.(*value.BinaryExpr); ok && assign.Op == "=" {
				vars = append(vars, varsOf(assign.Left)...)
			}
		}
	}
	if path == "_test" {
		fmt.Println(vars)
	}
	return sorted(vars)
}

func varsOf(expr value.Expr) []string {
	switch expr := expr.(type) {
	case *value.VarExpr:
		if !strings.HasPrefix(expr.Name, "_") {
			return []string{expr.Name}
		}
	case value.VectorExpr:
		var vs []string
		for _, e := range expr {
			vs = append(vs, varsOf(e)...)
		}
		return vs
	case *value.IndexExpr:
		return varsOf(expr.Left)
	}
	return nil
}

// doc returns, after minor formatting, the comment that opens the file.
func doc(lines []string) string {
	docs := ""
	for _, line := range lines {
		line = strings.TrimSpace(line)
		if !strings.HasPrefix(line, "#") {
			break
		}
		line = line[1:]
		if !strings.HasPrefix(line, "\t") {
			line = strings.TrimSpace(line)
		}
		docs += line + "\n"
	}
	str := strconv.Quote(docs)
	return str
}

func ops(lines []string) string {
	fns := []string{}
	for _, line := range lines {
		line = strings.TrimSpace(line)
		if !strings.HasPrefix(line, "op ") && !strings.HasPrefix(line, "op\t") || !strings.Contains(line, "=") {
			continue
		}
		line = line[:strings.Index(line, "=")]
		words := declFields(line)
		if words == nil {
			log.Fatal("cannot handle declaration: ", line)
		}
		name := ""
		switch len(words) {
		case 3:
			name = words[1]
		case 4:
			name = words[2]
		default:
			log.Fatal("cannot handle declaration: ", line)
			continue
		}
		if !strings.HasPrefix(name, "_") {
			fns = append(fns, name)
		}
	}
	return sorted(fns)
}

func sorted(words []string) string {
	sort.Strings(words)
	words = unique(words)
	str := ""
	for i, fn := range words {
		if i > 0 {
			str += " "
		}
		str += fn
	}
	return str
}

func unique(words []string) []string {
	out := []string{}
	for i, word := range words {
		if i == 0 || word != words[i-1] {
			out = append(out, word)
		}
	}
	return out
}

func isAlphaNum(r byte) bool {
	return r == '_' || 'a' <= r && r <= 'z' || 'A' <= r && r <= 'Z' || '0' <= r && r <= '9'
}

func declFields(line string) []string {
	words := []string{}
	word := []byte{}
	addWord := func() {
		words = append(words, string(word))
		word = word[:0]
	}
	for i := 0; i < len(line); i++ {
		r := line[i]
		switch {
		case r == '#':
			return words
		case r == ' ', r == '\t':
			if len(word) != 0 {
				addWord()
			}
		case isAlphaNum(r):
			word = append(word, r)
		case r == '(':
			for ; i < len(line); i++ {
				r = line[i]
				word = append(word, r)
				if r == ')' {
					addWord()
					break
				}
			}
		}
	}
	if len(word) != 0 {
		words = append(words, string(word))
	}
	return words
}
